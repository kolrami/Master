%!TEX root = thesis.tex
\chapter{Introduction}
%\epigraphhead[60]{\epigraph{``The future for PACs hinges on the incorporation
%of embedded technology''}{\textit{\citet{bel05}}}}

Modern industrial applications include a broad range of requirements, far
exceeding the traditional control and automation tasks. Buzzwords like
\emph{Industry 4.0} or the \emph{Internet of Things} emphasize the growing
demand of features. While a typical control system interfaces with simple
sensors and actuators, modern applications require more sophisticated features
like network connectivity, integration into enterprise systems or device
interoperability. To accommodate these new challenges and since the nowadays
dominating \ac{PLC} reaches its limits, the \ac{PAC} was introduced as the
next generation of control. It combines the reliability and robustness of a
\ac{PLC} with the advanced software capabilities of a \ac{PC}. By
incorporating state-of-the-art embedded technology like \acp{FPGA} and its
integration with general purpose processors on a single chip, these devices
eliminate the need for an expensive custom hardware and allow  the use of
\ac{CTOS} components, without loosing the benefits of executing time critical
control functions directly in silicon.

Unfortunately, the increasing complexity of such systems introduces new
challenges and demand convenient programming methods abstracting the
underlying low-level components, to make these devices accessible to a broad
range of developers. Classical ladder logic used for \acp{PLC} reaches its
limits and \ac{FPGA} technology is restricted to hardware designers capable of
handling low level programming languages like \ac{VHDL}. Because of its
acceptance in the field of software engineering and its eligibility to model
embedded systems composed of concurrently running tasks, the multithreaded
approach seems to be suitable as a convenient programming model for these
hybrid devices. The different threads specified by the developer are
distributed across the system's \ac{CPU} and \ac{FPGA} resources and
communicate via defined interaction mechanisms like message passing or shared
memory.\todo{Proposal Andreas}
\begin{itemize}
\item Develop a reconfigurable infrastructure for direct communication
between hardware threads. The new communication method should be integrated
into the ReconOS programming model as a new or as an extension of an existing
operating system abstraction. The choice of communication method should be
made by the runtime system in a way that is transparent for the programmer of
the hardeware thread.
\item Develop a toolchain that enables the use of \ac{HLS} for the creation of
ReconOS hardware threads. Investigate, how \ac{HLS} can be used to generate
the processing logic of a thread as well as the \ac{OSFSM}.
\item Implement a method to meassure the power consumption of the system.
Investigate means to meassure the on-chip power usage in a fine-grained way.
Investigate whether it is possible to meassure the power usage of individual
hardware threads.
\item Develop a \ac{PAC} that controlls a ball-on-plate application. The
application should contain components for the tracking of the ball, inverse
kinematics, and the required control algorithms. These components should be
implemented as a combination of hardware and software threads.
\item Use the previously developed application and components to meassure
thread performance, resource utilization and power consumption. Make the
application adapt to given goals and constraints by mechanisms like switching
on and off hardware and software threads, or switching between different
algorithms or implementations. Investigate different adaptation strategies
ranging from simple heuristics to more sophisticated methods involving machine
learning.
\end{itemize}